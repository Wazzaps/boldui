
LittleEndian();

struct String {
    uint64 len;
    char data[len];
};

struct Bytes {
    uint64 len;
    ubyte data[len];
};
        
struct A2RExtendedHelloResponse;

struct A2RHelloResponse;

struct A2RMessage;

struct A2RReparentScene;

struct A2RUpdate;

struct A2RUpdateScene;

struct CmdsCommand;

struct Color;

struct EA2RExtendedHelloResponse;

struct EA2RHelloResponse;

struct EA2RMessage;

struct Error;

struct EventType;

struct ExternalAppRequest;

struct HandlerBlock;

struct HandlerCmd;

struct OpId;

struct OpsOperation;

struct R2AExtendedHello;

struct R2AHello;

struct R2AMessage;

struct R2AOpen;

struct R2AReply;

struct R2AUpdate;

struct R2EAExtendedHello;

struct R2EAHello;

struct R2EAMessage;

struct R2EAOpen;

struct R2EAUpdate;

struct Value;

struct VarId;

struct Watch;


struct A2RExtendedHelloResponse {
};


struct A2RHelloResponse {
    uint16 protocol_major_version;
    uint16 protocol_minor_version;
    uint32 extra_len;
    struct { ubyte is_some; if (is_some) { Error item; } } error;
};


enum <uint32> A2RMessage_TAGS {
    A2RMessage_Update = 0,
    A2RMessage_Error = 1,
    A2RMessage_CompressedUpdate = 2,
};

struct A2RMessage {
    enum A2RMessage_TAGS _tag;

    if (_tag == 0) {
        A2RUpdate value;
    }

    if (_tag == 1) {
        Error value;
    }

    if (_tag == 2) {
        struct { uint64 len; ubyte items[len] <optimize=false>; } value;
    }

};

enum <uint32> A2RReparentScene_TAGS {
    A2RReparentScene_Inside = 0,
    A2RReparentScene_After = 1,
    A2RReparentScene_Root = 2,
    A2RReparentScene_Disconnect = 3,
    A2RReparentScene_Hide = 4,
};

struct A2RReparentScene {
    enum A2RReparentScene_TAGS _tag;

    if (_tag == 0) {
        uint32 value;
    }

    if (_tag == 1) {
        uint32 value;
    }

    if (_tag == 2) {
    }

    if (_tag == 3) {
    }

    if (_tag == 4) {
    }

};

struct A2RUpdate {
    struct { uint64 len; A2RUpdateScene items[len] <optimize=false>; } updated_scenes;
    struct { uint64 len; HandlerBlock items[len] <optimize=false>; } run_blocks;
    struct { uint64 len; ExternalAppRequest items[len] <optimize=false>; } external_app_requests;
};


struct A2RUpdateScene {
    uint32 id;
    OpId paint;
    OpId backdrop;
    OpId transform;
    OpId clip;
    String uri;
    OpId dimensions;
    struct { uint64 len; OpsOperation items[len] <optimize=false>; } ops;
    struct { uint64 len; CmdsCommand items[len] <optimize=false>; } cmds;
    struct { uint64 len; struct { String key; Value value; } items[len] <optimize=false>; } var_decls;
    struct { uint64 len; Watch items[len] <optimize=false>; } watches;
    struct { uint64 len; struct { EventType f0; HandlerBlock f1; } items[len] <optimize=false>; } event_handlers;
};


enum <uint32> CmdsCommand_TAGS {
    CmdsCommand_Clear = 0,
    CmdsCommand_DrawRect = 1,
    CmdsCommand_DrawRoundRect = 2,
    CmdsCommand_DrawCenteredText = 3,
};

struct CmdsCommand {
    enum CmdsCommand_TAGS _tag;

    if (_tag == 0) {
        OpId color;
    }

    if (_tag == 1) {
        OpId paint;
        OpId rect;
    }

    if (_tag == 2) {
        OpId paint;
        OpId rect;
        OpId radius;
    }

    if (_tag == 3) {
        OpId text;
        OpId paint;
        OpId center;
    }

};

struct Color {
    uint16 r;
    uint16 g;
    uint16 b;
    uint16 a;
};


struct EA2RExtendedHelloResponse {
};


struct EA2RHelloResponse {
    uint16 protocol_major_version;
    uint16 protocol_minor_version;
    uint32 extra_len;
    struct { ubyte is_some; if (is_some) { Error item; } } error;
};


enum <uint32> EA2RMessage_TAGS {
    EA2RMessage_CreatedExternalWidget = 0,
    EA2RMessage_SpontaneousUpdate = 1,
    EA2RMessage_UpdateHandled = 2,
    EA2RMessage_Error = 3,
};

struct EA2RMessage {
    enum EA2RMessage_TAGS _tag;

    if (_tag == 0) {
        struct { uint64 len; ubyte items[len] <optimize=false>; } texture_info;
    }

    if (_tag == 1) {
    }

    if (_tag == 2) {
    }

    if (_tag == 3) {
        Error value;
    }

};

struct Error {
    uint64 code;
    String text;
};


enum <uint32> EventType_TAGS {
    EventType_MouseDown = 0,
    EventType_MouseUp = 1,
};

struct EventType {
    enum EventType_TAGS _tag;

    if (_tag == 0) {
        OpId rect;
    }

    if (_tag == 1) {
        OpId rect;
    }

};

struct ExternalAppRequest {
    uint32 scene_id;
    String uri;
};


struct HandlerBlock {
    struct { uint64 len; OpsOperation items[len] <optimize=false>; } ops;
    struct { uint64 len; HandlerCmd items[len] <optimize=false>; } cmds;
};


enum <uint32> HandlerCmd_TAGS {
    HandlerCmd_Nop = 0,
    HandlerCmd_AllocateWindowId = 1,
    HandlerCmd_ReparentScene = 2,
    HandlerCmd_UpdateVar = 3,
    HandlerCmd_DebugMessage = 4,
    HandlerCmd_Reply = 5,
    HandlerCmd_If = 6,
};

struct HandlerCmd {
    enum HandlerCmd_TAGS _tag;

    if (_tag == 0) {
    }

    if (_tag == 1) {
    }

    if (_tag == 2) {
        uint32 scene;
        A2RReparentScene to;
    }

    if (_tag == 3) {
        VarId var;
        OpId value;
    }

    if (_tag == 4) {
        String msg;
    }

    if (_tag == 5) {
        String path;
        struct { uint64 len; OpId items[len] <optimize=false>; } params;
    }

    if (_tag == 6) {
        OpId condition;
        HandlerCmd then;
        HandlerCmd or_else;
    }

};

struct OpId {
    uint32 scene_id;
    uint32 idx;
};


enum <uint32> OpsOperation_TAGS {
    OpsOperation_Value = 0,
    OpsOperation_Var = 1,
    OpsOperation_GetTime = 2,
    OpsOperation_GetTimeAndClamp = 3,
    OpsOperation_Add = 4,
    OpsOperation_Neg = 5,
    OpsOperation_Mul = 6,
    OpsOperation_Div = 7,
    OpsOperation_FloorDiv = 8,
    OpsOperation_Eq = 9,
    OpsOperation_Min = 10,
    OpsOperation_Max = 11,
    OpsOperation_Or = 12,
    OpsOperation_And = 13,
    OpsOperation_GreaterThan = 14,
    OpsOperation_Abs = 15,
    OpsOperation_Sin = 16,
    OpsOperation_Cos = 17,
    OpsOperation_MakePoint = 18,
    OpsOperation_MakeRectFromPoints = 19,
    OpsOperation_MakeRectFromSides = 20,
    OpsOperation_MakeColor = 21,
    OpsOperation_ToString = 22,
    OpsOperation_If = 23,
};

struct OpsOperation {
    enum OpsOperation_TAGS _tag;

    if (_tag == 0) {
        Value value;
    }

    if (_tag == 1) {
        VarId value;
    }

    if (_tag == 2) {
    }

    if (_tag == 3) {
        OpId low;
        OpId high;
    }

    if (_tag == 4) {
        OpId a;
        OpId b;
    }

    if (_tag == 5) {
        OpId a;
    }

    if (_tag == 6) {
        OpId a;
        OpId b;
    }

    if (_tag == 7) {
        OpId a;
        OpId b;
    }

    if (_tag == 8) {
        OpId a;
        OpId b;
    }

    if (_tag == 9) {
        OpId a;
        OpId b;
    }

    if (_tag == 10) {
        OpId a;
        OpId b;
    }

    if (_tag == 11) {
        OpId a;
        OpId b;
    }

    if (_tag == 12) {
        OpId a;
        OpId b;
    }

    if (_tag == 13) {
        OpId a;
        OpId b;
    }

    if (_tag == 14) {
        OpId a;
        OpId b;
    }

    if (_tag == 15) {
        OpId a;
    }

    if (_tag == 16) {
        OpId a;
    }

    if (_tag == 17) {
        OpId a;
    }

    if (_tag == 18) {
        OpId left;
        OpId top;
    }

    if (_tag == 19) {
        OpId left_top;
        OpId right_bottom;
    }

    if (_tag == 20) {
        OpId left;
        OpId top;
        OpId right;
        OpId bottom;
    }

    if (_tag == 21) {
        OpId r;
        OpId g;
        OpId b;
        OpId a;
    }

    if (_tag == 22) {
        OpId a;
    }

    if (_tag == 23) {
        OpId condition;
        OpId then;
        OpId or_else;
    }

};

struct R2AExtendedHello {
};


struct R2AHello {
    uint16 min_protocol_major_version;
    uint16 min_protocol_minor_version;
    uint16 max_protocol_major_version;
    uint32 extra_len;
};


enum <uint32> R2AMessage_TAGS {
    R2AMessage_Update = 0,
    R2AMessage_Open = 1,
    R2AMessage_Error = 2,
};

struct R2AMessage {
    enum R2AMessage_TAGS _tag;

    if (_tag == 0) {
        R2AUpdate value;
    }

    if (_tag == 1) {
        R2AOpen value;
    }

    if (_tag == 2) {
        Error value;
    }

};

struct R2AOpen {
    String path;
};


struct R2AReply {
    String path;
    struct { uint64 len; Value items[len] <optimize=false>; } params;
};


struct R2AUpdate {
    struct { uint64 len; R2AReply items[len] <optimize=false>; } replies;
};


struct R2EAExtendedHello {
};


struct R2EAHello {
    uint16 min_protocol_major_version;
    uint16 min_protocol_minor_version;
    uint16 max_protocol_major_version;
    uint32 extra_len;
};


enum <uint32> R2EAMessage_TAGS {
    R2EAMessage_Update = 0,
    R2EAMessage_Open = 1,
    R2EAMessage_Error = 2,
};

struct R2EAMessage {
    enum R2EAMessage_TAGS _tag;

    if (_tag == 0) {
        R2EAUpdate value;
    }

    if (_tag == 1) {
        R2EAOpen value;
    }

    if (_tag == 2) {
        Error value;
    }

};

struct R2EAOpen {
    String path;
};


struct R2EAUpdate {
    struct { uint64 len; struct { String f0; Value f1; } items[len] <optimize=false>; } changed_vars;
};


enum <uint32> Value_TAGS {
    Value_Sint64 = 0,
    Value_Double = 1,
    Value_String = 2,
    Value_Color = 3,
    Value_Point = 4,
    Value_Rect = 5,
};

struct Value {
    enum Value_TAGS _tag;

    if (_tag == 0) {
        int64 value;
    }

    if (_tag == 1) {
        double value;
    }

    if (_tag == 2) {
        String value;
    }

    if (_tag == 3) {
        Color value;
    }

    if (_tag == 4) {
        double left;
        double top;
    }

    if (_tag == 5) {
        double left;
        double top;
        double right;
        double bottom;
    }

};

struct VarId {
    uint32 scene;
    String key;
};


struct Watch {
    OpId condition;
    HandlerBlock handler;
};


char magic[7];
if (Memcmp(magic, "BOLDUI\x01", sizeof("BOLDUI\x01")-1) == 0) {
    A2RHelloResponse hello_res;
    A2RExtendedHelloResponse ext_hello_res;
    while (!FEof()) {
        uint32 msg_len;
        A2RMessage msg;
    }
}
        
