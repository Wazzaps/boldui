
LittleEndian();

struct String {
    uint64 len;
    char data[len];
};

struct Bytes {
    uint64 len;
    ubyte data[len];
};
        
struct A2RExtendedHelloResponse;

struct A2RHelloResponse;

struct A2RMessage;

struct A2RReparentScene;

struct A2RUpdate;

struct A2RUpdateScene;

struct CmdsCommand;

struct Color;

struct EA2RExtendedHelloResponse;

struct EA2RHelloResponse;

struct EA2RMessage;

struct Error;

struct EventHandler;

struct EventType;

struct ExternalAppRequest;

struct HandlerBlock;

struct HandlerCmd;

struct OpId;

struct OpsOperation;

struct R2AExtendedHello;

struct R2AHello;

struct R2AMessage;

struct R2AOpen;

struct R2AReply;

struct R2AUpdate;

struct R2EAExtendedHello;

struct R2EAHello;

struct R2EAMessage;

struct R2EAOpen;

struct R2EAUpdate;

struct ResourceChunk;

struct ResourceDealloc;

struct SceneAttr;

struct Value;

struct VarId;

struct Watch;


struct A2RExtendedHelloResponse {
};


struct A2RHelloResponse {
    uint16 protocol_major_version;
    uint16 protocol_minor_version;
    uint32 extra_len;
    struct { ubyte is_some; if (is_some) { Error item; } } error;
};


enum <uint32> A2RMessage_TAGS {
    A2RMessage_Update = 0,
    A2RMessage_Error = 1,
    A2RMessage_CompressedUpdate = 2,
};

struct A2RMessage {
    enum A2RMessage_TAGS _tag;

    if (_tag == 0) {
        A2RUpdate value;
    }

    if (_tag == 1) {
        Error value;
    }

    if (_tag == 2) {
        struct { uint64 len; ubyte items[len] <optimize=false>; } value;
    }

};

enum <uint32> A2RReparentScene_TAGS {
    A2RReparentScene_Inside = 0,
    A2RReparentScene_After = 1,
    A2RReparentScene_Root = 2,
    A2RReparentScene_Disconnect = 3,
    A2RReparentScene_Hide = 4,
};

struct A2RReparentScene {
    enum A2RReparentScene_TAGS _tag;

    if (_tag == 0) {
        OpId value;
    }

    if (_tag == 1) {
        OpId value;
    }

    if (_tag == 2) {
    }

    if (_tag == 3) {
    }

    if (_tag == 4) {
    }

};

struct A2RUpdate {
    struct { uint64 len; A2RUpdateScene items[len] <optimize=false>; } updated_scenes;
    struct { uint64 len; HandlerBlock items[len] <optimize=false>; } run_blocks;
    struct { uint64 len; ResourceChunk items[len] <optimize=false>; } resource_chunks;
    struct { uint64 len; ResourceDealloc items[len] <optimize=false>; } resource_deallocs;
    struct { uint64 len; ExternalAppRequest items[len] <optimize=false>; } external_app_requests;
};


struct A2RUpdateScene {
    uint32 id;
    struct { uint64 len; struct { uint32 key; OpId value; } items[len] <optimize=false>; } attrs;
    struct { uint64 len; OpsOperation items[len] <optimize=false>; } ops;
    struct { uint64 len; CmdsCommand items[len] <optimize=false>; } cmds;
    struct { uint64 len; Watch items[len] <optimize=false>; } watches;
    struct { uint64 len; EventHandler items[len] <optimize=false>; } event_handlers;
};


enum <uint32> CmdsCommand_TAGS {
    CmdsCommand_Clear = 0,
    CmdsCommand_DrawRect = 1,
    CmdsCommand_DrawRoundRect = 2,
    CmdsCommand_DrawCenteredText = 3,
    CmdsCommand_DrawImage = 4,
};

struct CmdsCommand {
    enum CmdsCommand_TAGS _tag;

    if (_tag == 0) {
        OpId color;
    }

    if (_tag == 1) {
        OpId paint;
        OpId rect;
    }

    if (_tag == 2) {
        OpId paint;
        OpId rect;
        OpId radius;
    }

    if (_tag == 3) {
        OpId text;
        OpId paint;
        OpId center;
    }

    if (_tag == 4) {
        OpId res;
        OpId top_left;
    }

};

struct Color {
    uint16 r;
    uint16 g;
    uint16 b;
    uint16 a;
};


struct EA2RExtendedHelloResponse {
};


struct EA2RHelloResponse {
    uint16 protocol_major_version;
    uint16 protocol_minor_version;
    uint32 extra_len;
    struct { ubyte is_some; if (is_some) { Error item; } } error;
};


enum <uint32> EA2RMessage_TAGS {
    EA2RMessage_CreatedExternalWidget = 0,
    EA2RMessage_SpontaneousUpdate = 1,
    EA2RMessage_UpdateHandled = 2,
    EA2RMessage_Error = 3,
};

struct EA2RMessage {
    enum EA2RMessage_TAGS _tag;

    if (_tag == 0) {
        struct { uint64 len; ubyte items[len] <optimize=false>; } texture_info;
    }

    if (_tag == 1) {
    }

    if (_tag == 2) {
    }

    if (_tag == 3) {
        Error value;
    }

};

struct Error {
    uint64 code;
    String text;
};


struct EventHandler {
    EventType event_type;
    HandlerBlock handler;
    OpId continue_handling;
};


enum <uint32> EventType_TAGS {
    EventType_MouseDown = 0,
    EventType_MouseUp = 1,
    EventType_MouseMove = 2,
};

struct EventType {
    enum EventType_TAGS _tag;

    if (_tag == 0) {
        OpId rect;
    }

    if (_tag == 1) {
        OpId rect;
    }

    if (_tag == 2) {
        OpId rect;
    }

};

struct ExternalAppRequest {
    uint32 scene_id;
    String uri;
};


struct HandlerBlock {
    struct { uint64 len; OpsOperation items[len] <optimize=false>; } ops;
    struct { uint64 len; HandlerCmd items[len] <optimize=false>; } cmds;
};


enum <uint32> HandlerCmd_TAGS {
    HandlerCmd_Nop = 0,
    HandlerCmd_AllocateWindowId = 1,
    HandlerCmd_ReparentScene = 2,
    HandlerCmd_SetVar = 3,
    HandlerCmd_SetVarByRef = 4,
    HandlerCmd_DeleteVar = 5,
    HandlerCmd_DeleteVarByRef = 6,
    HandlerCmd_DebugMessage = 7,
    HandlerCmd_Reply = 8,
    HandlerCmd_Open = 9,
    HandlerCmd_If = 10,
};

struct HandlerCmd {
    enum HandlerCmd_TAGS _tag;

    if (_tag == 0) {
    }

    if (_tag == 1) {
    }

    if (_tag == 2) {
        OpId scene;
        A2RReparentScene to;
    }

    if (_tag == 3) {
        VarId var;
        OpId value;
    }

    if (_tag == 4) {
        OpId var;
        OpId value;
    }

    if (_tag == 5) {
        VarId var;
        OpId value;
    }

    if (_tag == 6) {
        OpId var;
        OpId value;
    }

    if (_tag == 7) {
        String msg;
    }

    if (_tag == 8) {
        String path;
        struct { uint64 len; OpId items[len] <optimize=false>; } params;
    }

    if (_tag == 9) {
        String path;
    }

    if (_tag == 10) {
        OpId condition;
        struct { uint64 len; HandlerCmd items[len] <optimize=false>; } then;
        struct { uint64 len; HandlerCmd items[len] <optimize=false>; } or_else;
    }

};

struct OpId {
    uint32 scene_id;
    uint32 idx;
};


enum <uint32> OpsOperation_TAGS {
    OpsOperation_Value = 0,
    OpsOperation_Var = 1,
    OpsOperation_GetTime = 2,
    OpsOperation_GetTimeAndClamp = 3,
    OpsOperation_Add = 4,
    OpsOperation_Neg = 5,
    OpsOperation_Mul = 6,
    OpsOperation_Div = 7,
    OpsOperation_FloorDiv = 8,
    OpsOperation_Eq = 9,
    OpsOperation_Neq = 10,
    OpsOperation_Min = 11,
    OpsOperation_Max = 12,
    OpsOperation_Or = 13,
    OpsOperation_And = 14,
    OpsOperation_GreaterThan = 15,
    OpsOperation_Abs = 16,
    OpsOperation_Sin = 17,
    OpsOperation_Cos = 18,
    OpsOperation_MakePoint = 19,
    OpsOperation_MakeRectFromPoints = 20,
    OpsOperation_MakeRectFromSides = 21,
    OpsOperation_MakeColor = 22,
    OpsOperation_ToString = 23,
    OpsOperation_GetImageDimensions = 24,
    OpsOperation_GetPointTop = 25,
    OpsOperation_GetPointLeft = 26,
    OpsOperation_If = 27,
};

struct OpsOperation {
    enum OpsOperation_TAGS _tag;

    if (_tag == 0) {
        Value value;
    }

    if (_tag == 1) {
        VarId value;
    }

    if (_tag == 2) {
    }

    if (_tag == 3) {
        OpId low;
        OpId high;
    }

    if (_tag == 4) {
        OpId a;
        OpId b;
    }

    if (_tag == 5) {
        OpId a;
    }

    if (_tag == 6) {
        OpId a;
        OpId b;
    }

    if (_tag == 7) {
        OpId a;
        OpId b;
    }

    if (_tag == 8) {
        OpId a;
        OpId b;
    }

    if (_tag == 9) {
        OpId a;
        OpId b;
    }

    if (_tag == 10) {
        OpId a;
        OpId b;
    }

    if (_tag == 11) {
        OpId a;
        OpId b;
    }

    if (_tag == 12) {
        OpId a;
        OpId b;
    }

    if (_tag == 13) {
        OpId a;
        OpId b;
    }

    if (_tag == 14) {
        OpId a;
        OpId b;
    }

    if (_tag == 15) {
        OpId a;
        OpId b;
    }

    if (_tag == 16) {
        OpId a;
    }

    if (_tag == 17) {
        OpId a;
    }

    if (_tag == 18) {
        OpId a;
    }

    if (_tag == 19) {
        OpId left;
        OpId top;
    }

    if (_tag == 20) {
        OpId left_top;
        OpId right_bottom;
    }

    if (_tag == 21) {
        OpId left;
        OpId top;
        OpId right;
        OpId bottom;
    }

    if (_tag == 22) {
        OpId r;
        OpId g;
        OpId b;
        OpId a;
    }

    if (_tag == 23) {
        OpId a;
    }

    if (_tag == 24) {
        OpId res;
    }

    if (_tag == 25) {
        OpId point;
    }

    if (_tag == 26) {
        OpId point;
    }

    if (_tag == 27) {
        OpId condition;
        OpId then;
        OpId or_else;
    }

};

struct R2AExtendedHello {
};


struct R2AHello {
    uint16 min_protocol_major_version;
    uint16 min_protocol_minor_version;
    uint16 max_protocol_major_version;
    uint32 extra_len;
};


enum <uint32> R2AMessage_TAGS {
    R2AMessage_Update = 0,
    R2AMessage_Open = 1,
    R2AMessage_Error = 2,
};

struct R2AMessage {
    enum R2AMessage_TAGS _tag;

    if (_tag == 0) {
        R2AUpdate value;
    }

    if (_tag == 1) {
        R2AOpen value;
    }

    if (_tag == 2) {
        Error value;
    }

};

struct R2AOpen {
    String path;
};


struct R2AReply {
    String path;
    struct { uint64 len; Value items[len] <optimize=false>; } params;
};


struct R2AUpdate {
    struct { uint64 len; R2AReply items[len] <optimize=false>; } replies;
};


struct R2EAExtendedHello {
};


struct R2EAHello {
    uint16 min_protocol_major_version;
    uint16 min_protocol_minor_version;
    uint16 max_protocol_major_version;
    uint32 extra_len;
};


enum <uint32> R2EAMessage_TAGS {
    R2EAMessage_Update = 0,
    R2EAMessage_Open = 1,
    R2EAMessage_Error = 2,
};

struct R2EAMessage {
    enum R2EAMessage_TAGS _tag;

    if (_tag == 0) {
        R2EAUpdate value;
    }

    if (_tag == 1) {
        R2EAOpen value;
    }

    if (_tag == 2) {
        Error value;
    }

};

struct R2EAOpen {
    String path;
};


struct R2EAUpdate {
    struct { uint64 len; struct { String f0; Value f1; } items[len] <optimize=false>; } changed_vars;
};


struct ResourceChunk {
    uint32 id;
    uint64 offset;
    struct { uint64 len; ubyte items[len] <optimize=false>; } data;
};


struct ResourceDealloc {
    uint32 id;
    uint64 offset;
    uint64 length;
};


enum <uint32> SceneAttr_TAGS {
    SceneAttr_Transform = 0,
    SceneAttr_Paint = 1,
    SceneAttr_BackdropPaint = 2,
    SceneAttr_Clip = 3,
    SceneAttr_Uri = 4,
    SceneAttr_Size = 5,
    SceneAttr_WindowId = 6,
    SceneAttr_WindowInitialPosition = 7,
    SceneAttr_WindowInitialState = 8,
    SceneAttr_WindowTitle = 9,
    SceneAttr_WindowIcon = 10,
    SceneAttr_WindowDecorations = 11,
};

struct SceneAttr {
    enum SceneAttr_TAGS _tag;

    if (_tag == 0) {
    }

    if (_tag == 1) {
    }

    if (_tag == 2) {
    }

    if (_tag == 3) {
    }

    if (_tag == 4) {
    }

    if (_tag == 5) {
    }

    if (_tag == 6) {
    }

    if (_tag == 7) {
    }

    if (_tag == 8) {
    }

    if (_tag == 9) {
    }

    if (_tag == 10) {
    }

    if (_tag == 11) {
    }

};

enum <uint32> Value_TAGS {
    Value_Sint64 = 0,
    Value_Double = 1,
    Value_String = 2,
    Value_Color = 3,
    Value_Resource = 4,
    Value_VarRef = 5,
    Value_Point = 6,
    Value_Rect = 7,
};

struct Value {
    enum Value_TAGS _tag;

    if (_tag == 0) {
        int64 value;
    }

    if (_tag == 1) {
        double value;
    }

    if (_tag == 2) {
        String value;
    }

    if (_tag == 3) {
        Color value;
    }

    if (_tag == 4) {
        uint32 value;
    }

    if (_tag == 5) {
        VarId value;
    }

    if (_tag == 6) {
        double left;
        double top;
    }

    if (_tag == 7) {
        double left;
        double top;
        double right;
        double bottom;
    }

};

struct VarId {
    String key;
};


struct Watch {
    OpId condition;
    HandlerBlock handler;
};


char magic[7];
if (Memcmp(magic, "BOLDUI\x01", sizeof("BOLDUI\x01")-1) == 0) {
    A2RHelloResponse hello_res;
    A2RExtendedHelloResponse ext_hello_res;
    while (!FEof()) {
        uint32 msg_len;
        A2RMessage msg;
    }
}
        
